{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\"; // TYPES\n// FUNCTIONS\n\nfunction dehydrateMutation(mutation) {\n  return {\n    mutationKey: mutation.options.mutationKey,\n    state: mutation.state\n  };\n} // Most config is not dehydrated but instead meant to configure again when\n// consuming the de/rehydrated data, typically with useQuery on the client.\n// Sometimes it might make sense to prefetch data on the server and include\n// in the html-payload, but not consume it on the initial render.\n\n\nfunction dehydrateQuery(query) {\n  return {\n    state: query.state,\n    queryKey: query.queryKey,\n    queryHash: query.queryHash\n  };\n}\n\nfunction defaultShouldDehydrateMutation(mutation) {\n  return mutation.state.isPaused;\n}\n\nfunction defaultShouldDehydrateQuery(query) {\n  return query.state.status === 'success';\n}\n\nexport function dehydrate(client, options) {\n  var _options, _options2;\n\n  options = options || {};\n  var mutations = [];\n  var queries = [];\n\n  if (((_options = options) == null ? void 0 : _options.dehydrateMutations) !== false) {\n    var shouldDehydrateMutation = options.shouldDehydrateMutation || defaultShouldDehydrateMutation;\n    client.getMutationCache().getAll().forEach(function (mutation) {\n      if (shouldDehydrateMutation(mutation)) {\n        mutations.push(dehydrateMutation(mutation));\n      }\n    });\n  }\n\n  if (((_options2 = options) == null ? void 0 : _options2.dehydrateQueries) !== false) {\n    var shouldDehydrateQuery = options.shouldDehydrateQuery || defaultShouldDehydrateQuery;\n    client.getQueryCache().getAll().forEach(function (query) {\n      if (shouldDehydrateQuery(query)) {\n        queries.push(dehydrateQuery(query));\n      }\n    });\n  }\n\n  return {\n    mutations: mutations,\n    queries: queries\n  };\n}\nexport function hydrate(client, dehydratedState, options) {\n  if (typeof dehydratedState !== 'object' || dehydratedState === null) {\n    return;\n  }\n\n  var mutationCache = client.getMutationCache();\n  var queryCache = client.getQueryCache();\n  var mutations = dehydratedState.mutations || [];\n  var queries = dehydratedState.queries || [];\n  mutations.forEach(function (dehydratedMutation) {\n    var _options$defaultOptio;\n\n    mutationCache.build(client, _extends({}, options == null ? void 0 : (_options$defaultOptio = options.defaultOptions) == null ? void 0 : _options$defaultOptio.mutations, {\n      mutationKey: dehydratedMutation.mutationKey\n    }), dehydratedMutation.state);\n  });\n  queries.forEach(function (dehydratedQuery) {\n    var _options$defaultOptio2;\n\n    var query = queryCache.get(dehydratedQuery.queryHash); // Do not hydrate if an existing query exists with newer data\n\n    if (query) {\n      if (query.state.dataUpdatedAt < dehydratedQuery.state.dataUpdatedAt) {\n        query.setState(dehydratedQuery.state);\n      }\n\n      return;\n    } // Restore query\n\n\n    queryCache.build(client, _extends({}, options == null ? void 0 : (_options$defaultOptio2 = options.defaultOptions) == null ? void 0 : _options$defaultOptio2.queries, {\n      queryKey: dehydratedQuery.queryKey,\n      queryHash: dehydratedQuery.queryHash\n    }), dehydratedQuery.state);\n  });\n}","map":{"version":3,"names":["_extends","dehydrateMutation","mutation","mutationKey","options","state","dehydrateQuery","query","queryKey","queryHash","defaultShouldDehydrateMutation","isPaused","defaultShouldDehydrateQuery","status","dehydrate","client","_options","_options2","mutations","queries","dehydrateMutations","shouldDehydrateMutation","getMutationCache","getAll","forEach","push","dehydrateQueries","shouldDehydrateQuery","getQueryCache","hydrate","dehydratedState","mutationCache","queryCache","dehydratedMutation","_options$defaultOptio","build","defaultOptions","dehydratedQuery","_options$defaultOptio2","get","dataUpdatedAt","setState"],"sources":["/home/honza/node_modules/react-query/es/core/hydration.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\n\n// TYPES\n// FUNCTIONS\nfunction dehydrateMutation(mutation) {\n  return {\n    mutationKey: mutation.options.mutationKey,\n    state: mutation.state\n  };\n} // Most config is not dehydrated but instead meant to configure again when\n// consuming the de/rehydrated data, typically with useQuery on the client.\n// Sometimes it might make sense to prefetch data on the server and include\n// in the html-payload, but not consume it on the initial render.\n\n\nfunction dehydrateQuery(query) {\n  return {\n    state: query.state,\n    queryKey: query.queryKey,\n    queryHash: query.queryHash\n  };\n}\n\nfunction defaultShouldDehydrateMutation(mutation) {\n  return mutation.state.isPaused;\n}\n\nfunction defaultShouldDehydrateQuery(query) {\n  return query.state.status === 'success';\n}\n\nexport function dehydrate(client, options) {\n  var _options, _options2;\n\n  options = options || {};\n  var mutations = [];\n  var queries = [];\n\n  if (((_options = options) == null ? void 0 : _options.dehydrateMutations) !== false) {\n    var shouldDehydrateMutation = options.shouldDehydrateMutation || defaultShouldDehydrateMutation;\n    client.getMutationCache().getAll().forEach(function (mutation) {\n      if (shouldDehydrateMutation(mutation)) {\n        mutations.push(dehydrateMutation(mutation));\n      }\n    });\n  }\n\n  if (((_options2 = options) == null ? void 0 : _options2.dehydrateQueries) !== false) {\n    var shouldDehydrateQuery = options.shouldDehydrateQuery || defaultShouldDehydrateQuery;\n    client.getQueryCache().getAll().forEach(function (query) {\n      if (shouldDehydrateQuery(query)) {\n        queries.push(dehydrateQuery(query));\n      }\n    });\n  }\n\n  return {\n    mutations: mutations,\n    queries: queries\n  };\n}\nexport function hydrate(client, dehydratedState, options) {\n  if (typeof dehydratedState !== 'object' || dehydratedState === null) {\n    return;\n  }\n\n  var mutationCache = client.getMutationCache();\n  var queryCache = client.getQueryCache();\n  var mutations = dehydratedState.mutations || [];\n  var queries = dehydratedState.queries || [];\n  mutations.forEach(function (dehydratedMutation) {\n    var _options$defaultOptio;\n\n    mutationCache.build(client, _extends({}, options == null ? void 0 : (_options$defaultOptio = options.defaultOptions) == null ? void 0 : _options$defaultOptio.mutations, {\n      mutationKey: dehydratedMutation.mutationKey\n    }), dehydratedMutation.state);\n  });\n  queries.forEach(function (dehydratedQuery) {\n    var _options$defaultOptio2;\n\n    var query = queryCache.get(dehydratedQuery.queryHash); // Do not hydrate if an existing query exists with newer data\n\n    if (query) {\n      if (query.state.dataUpdatedAt < dehydratedQuery.state.dataUpdatedAt) {\n        query.setState(dehydratedQuery.state);\n      }\n\n      return;\n    } // Restore query\n\n\n    queryCache.build(client, _extends({}, options == null ? void 0 : (_options$defaultOptio2 = options.defaultOptions) == null ? void 0 : _options$defaultOptio2.queries, {\n      queryKey: dehydratedQuery.queryKey,\n      queryHash: dehydratedQuery.queryHash\n    }), dehydratedQuery.state);\n  });\n}"],"mappings":"AAAA,OAAOA,QAAP,MAAqB,oCAArB,C,CAEA;AACA;;AACA,SAASC,iBAAT,CAA2BC,QAA3B,EAAqC;EACnC,OAAO;IACLC,WAAW,EAAED,QAAQ,CAACE,OAAT,CAAiBD,WADzB;IAELE,KAAK,EAAEH,QAAQ,CAACG;EAFX,CAAP;AAID,C,CAAC;AACF;AACA;AACA;;;AAGA,SAASC,cAAT,CAAwBC,KAAxB,EAA+B;EAC7B,OAAO;IACLF,KAAK,EAAEE,KAAK,CAACF,KADR;IAELG,QAAQ,EAAED,KAAK,CAACC,QAFX;IAGLC,SAAS,EAAEF,KAAK,CAACE;EAHZ,CAAP;AAKD;;AAED,SAASC,8BAAT,CAAwCR,QAAxC,EAAkD;EAChD,OAAOA,QAAQ,CAACG,KAAT,CAAeM,QAAtB;AACD;;AAED,SAASC,2BAAT,CAAqCL,KAArC,EAA4C;EAC1C,OAAOA,KAAK,CAACF,KAAN,CAAYQ,MAAZ,KAAuB,SAA9B;AACD;;AAED,OAAO,SAASC,SAAT,CAAmBC,MAAnB,EAA2BX,OAA3B,EAAoC;EACzC,IAAIY,QAAJ,EAAcC,SAAd;;EAEAb,OAAO,GAAGA,OAAO,IAAI,EAArB;EACA,IAAIc,SAAS,GAAG,EAAhB;EACA,IAAIC,OAAO,GAAG,EAAd;;EAEA,IAAI,CAAC,CAACH,QAAQ,GAAGZ,OAAZ,KAAwB,IAAxB,GAA+B,KAAK,CAApC,GAAwCY,QAAQ,CAACI,kBAAlD,MAA0E,KAA9E,EAAqF;IACnF,IAAIC,uBAAuB,GAAGjB,OAAO,CAACiB,uBAAR,IAAmCX,8BAAjE;IACAK,MAAM,CAACO,gBAAP,GAA0BC,MAA1B,GAAmCC,OAAnC,CAA2C,UAAUtB,QAAV,EAAoB;MAC7D,IAAImB,uBAAuB,CAACnB,QAAD,CAA3B,EAAuC;QACrCgB,SAAS,CAACO,IAAV,CAAexB,iBAAiB,CAACC,QAAD,CAAhC;MACD;IACF,CAJD;EAKD;;EAED,IAAI,CAAC,CAACe,SAAS,GAAGb,OAAb,KAAyB,IAAzB,GAAgC,KAAK,CAArC,GAAyCa,SAAS,CAACS,gBAApD,MAA0E,KAA9E,EAAqF;IACnF,IAAIC,oBAAoB,GAAGvB,OAAO,CAACuB,oBAAR,IAAgCf,2BAA3D;IACAG,MAAM,CAACa,aAAP,GAAuBL,MAAvB,GAAgCC,OAAhC,CAAwC,UAAUjB,KAAV,EAAiB;MACvD,IAAIoB,oBAAoB,CAACpB,KAAD,CAAxB,EAAiC;QAC/BY,OAAO,CAACM,IAAR,CAAanB,cAAc,CAACC,KAAD,CAA3B;MACD;IACF,CAJD;EAKD;;EAED,OAAO;IACLW,SAAS,EAAEA,SADN;IAELC,OAAO,EAAEA;EAFJ,CAAP;AAID;AACD,OAAO,SAASU,OAAT,CAAiBd,MAAjB,EAAyBe,eAAzB,EAA0C1B,OAA1C,EAAmD;EACxD,IAAI,OAAO0B,eAAP,KAA2B,QAA3B,IAAuCA,eAAe,KAAK,IAA/D,EAAqE;IACnE;EACD;;EAED,IAAIC,aAAa,GAAGhB,MAAM,CAACO,gBAAP,EAApB;EACA,IAAIU,UAAU,GAAGjB,MAAM,CAACa,aAAP,EAAjB;EACA,IAAIV,SAAS,GAAGY,eAAe,CAACZ,SAAhB,IAA6B,EAA7C;EACA,IAAIC,OAAO,GAAGW,eAAe,CAACX,OAAhB,IAA2B,EAAzC;EACAD,SAAS,CAACM,OAAV,CAAkB,UAAUS,kBAAV,EAA8B;IAC9C,IAAIC,qBAAJ;;IAEAH,aAAa,CAACI,KAAd,CAAoBpB,MAApB,EAA4Bf,QAAQ,CAAC,EAAD,EAAKI,OAAO,IAAI,IAAX,GAAkB,KAAK,CAAvB,GAA2B,CAAC8B,qBAAqB,GAAG9B,OAAO,CAACgC,cAAjC,KAAoD,IAApD,GAA2D,KAAK,CAAhE,GAAoEF,qBAAqB,CAAChB,SAA1H,EAAqI;MACvKf,WAAW,EAAE8B,kBAAkB,CAAC9B;IADuI,CAArI,CAApC,EAEI8B,kBAAkB,CAAC5B,KAFvB;EAGD,CAND;EAOAc,OAAO,CAACK,OAAR,CAAgB,UAAUa,eAAV,EAA2B;IACzC,IAAIC,sBAAJ;;IAEA,IAAI/B,KAAK,GAAGyB,UAAU,CAACO,GAAX,CAAeF,eAAe,CAAC5B,SAA/B,CAAZ,CAHyC,CAGc;;IAEvD,IAAIF,KAAJ,EAAW;MACT,IAAIA,KAAK,CAACF,KAAN,CAAYmC,aAAZ,GAA4BH,eAAe,CAAChC,KAAhB,CAAsBmC,aAAtD,EAAqE;QACnEjC,KAAK,CAACkC,QAAN,CAAeJ,eAAe,CAAChC,KAA/B;MACD;;MAED;IACD,CAXwC,CAWvC;;;IAGF2B,UAAU,CAACG,KAAX,CAAiBpB,MAAjB,EAAyBf,QAAQ,CAAC,EAAD,EAAKI,OAAO,IAAI,IAAX,GAAkB,KAAK,CAAvB,GAA2B,CAACkC,sBAAsB,GAAGlC,OAAO,CAACgC,cAAlC,KAAqD,IAArD,GAA4D,KAAK,CAAjE,GAAqEE,sBAAsB,CAACnB,OAA5H,EAAqI;MACpKX,QAAQ,EAAE6B,eAAe,CAAC7B,QAD0I;MAEpKC,SAAS,EAAE4B,eAAe,CAAC5B;IAFyI,CAArI,CAAjC,EAGI4B,eAAe,CAAChC,KAHpB;EAID,CAlBD;AAmBD"},"metadata":{},"sourceType":"module"}